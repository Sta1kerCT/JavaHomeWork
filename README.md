# JavaHomeWork
В этом репозитории хранятся все мои выполненные домашние задания с первого семестра первого курса КТ(компьютерные технологии) ИТМО. Они разделены на пакеты, но для удобства я буду указывать коммит и пакет.

   "my scanner"(все классы вне пакетов): Заданием было создать свой сканнер на основе Reader'a,
так как встроенный сканнер в java работает долго, и при помощи нового созданного сканнера нужно было решить следующие задачи:

(в скобках будет указан класс являющийся решением данной задачи)
№1 (ReverseOctDec) Разработайте класс, читающий числа из стандартного ввода, и выводящий их на стандартный вывод в обратном порядке.
В каждой строке входа содержится некоторое количество целых чисел (возможно ноль). Числа разделены пробелами. Каждое число помещается в тип int.
Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе.
Порядок чисел в каждой строке также должен быть обратным к порядку чисел во входе.
Вход содержит не более 10^6 чисел и строк.

№2 (WordsStatInput) Разработайте класс, подсчитывающий статистику встречаемости слов во входном файле.
Словом называется непрерывная последовательность букв, апострофов (') и дефисов (Unicode category Punctuation, Dash).
Для подсчета статистики слова приводятся к нижнему регистру.
Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления.
Для каждого слова должна быть выведена одна строка, содержащая слово и число его вхождений во входном файле.
Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
(WordsStatWordsPrefix - модификация данного класса, которая выводит в выходной файл все различные префиксы длины 3 слов,
встречающихся во входном файле, в лексикографическом порядке. Слова длины меньшей 3 используются как есть.)

№3 (Wspp) Разработайте класс, который будет подсчитывать статистику встречаемости слов во входном файле.
Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему регистру.
Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
Программа должна работать за линейное от размера входного файла время.
Для реализации программы используйте Collections Framework.
Сложный вариант. Реализуйте и примените класс IntList, компактно хранящий список целых чисел.
(WsppLastL - модификация данного класса, которая вместо номеров вхождений во всем файле указывает только последнее вхождение в каждой строке.)

   "markup"(пакет markup): классы этого коммита являются решением следующей задачи:
Разработайте набор классов для текстовой разметки.
Класс Paragraph может содержать произвольное число других элементов разметки и текстовых элементов.
Класс Text – текстовый элемент.
Классы разметки Emphasis, Strong, Strikeout – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.
Все классы должны реализовывать метод toMarkdown(StringBuilder), который должен генерировать Markdown-разметку по следующим правилам:
```
текстовые элементы выводятся как есть;
выделенный текст окружается символами '*';
сильно выделенный текст окружается символами '__';
зачеркнутый текст окружается символами '~'. 
``` 
Следующий код должен успешно компилироваться:

    
    Paragraph paragraph = new Paragraph(List.of(
        new Strong(List.of(
            new Text("1"),
            new Strikeout(List.of(
                new Text("2"),
                new Emphasis(List.of(
                    new Text("3"),
                    new Text("4")
                )),
                new Text("5")
            )),
            new Text("6")
        ))
    ));
    
    
Вызов paragraph.toMarkdown(new StringBuilder()) должен заполнять переданный StringBuilder следующим содержимым:
```__1~2*34*5~6__```

Модификация:
Дополнительно реализуйте метод toHtml, генерирующий HTML-разметку:
выделеный текст окружается тегом em;
сильно выделеный текст окружается тегом strong;
зачеркнутый текст окружается тегом s.
Добавьте поддержку:
Нумерованных списков (класс OrderedList, тег ol): последовательность элементов
Ненумерованных списков (класс UnorderedList, тег ul): последовательность элементов
Элементов списка (класс ListItem, тег li): последовательность абзацев и списков
Для новых классов поддержка Markdown не требуется
   
   
   "markdown to html"(пакет md2html): класс этого коммита являeтся решением следующей задачи:
Разработайте конвертер из Markdown-разметки в HTML.
Конвертер должен поддерживать следующие возможности:
```Абзацы текста разделяются пустыми строками.
Элементы строчной разметки: выделение (* или _), сильное выделение (** или __), зачеркивание (--), код (`)
Заголовки (# * уровень заголовка)
```
Конвертер должен называться md2html.Md2Html и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
При выполнении этого ДЗ можно повторно использовать код ДЗ markup.
Конвертер может хранить исходные и сконвертированные данные в памяти, в том числе, одновременно.


   "game"(пакет game): классы этого коммита являются решением следующей задачи:
Реализуйте игру m,n,k (k в ряд на доске m×n).
Добавьте обработку ошибок ввода пользователя. В случае ошибочного хода пользователь должен иметь возможность сделать другой ход.
Добавьте обработку ошибок игроков. В случае ошибки игрок автоматически проигрывает.
Доска должна производить обработку хода (проверку корректности, изменение состояния и определение результата) за O(k).
Предотвратите жульничество: у игрока не должно быть возможности достать Board из Position.

"expression"(пакет expression): классы этого коммита являются решением следующей задачи:
Разработайте классы Const, Variable, Add, Subtract, Multiply, Divide для вычисления выражений с одной переменной в типе int (интерфейс Expression).
Классы должны позволять составлять выражения вида
```new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).evaluate(5)
```    
При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу evaluate. Таким образом, результатом вычисления приведенного примера должно стать число 7.
Метод toString должен выдавать запись выражения в полноскобочной форме. Например
```new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).toString()
```
            
должен выдавать ((2 * x) - 3).
Сложный вариант. Метод toMiniString (интерфейс ToMiniString) должен выдавать выражение с минимальным числом скобок. Например
```new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).toMiniString()
```         
должен выдавать 2 * x - 3.
Реализуйте метод equals, проверяющий, что два выражения совпадают. Например,
```new Multiply(new Const(2), new Variable("x"))
    .equals(new Multiply(new Const(2), new Variable("x")))
```            
должно выдавать true, а
```new Multiply(new Const(2), new Variable("x"))
    .equals(new Multiply(new Variable("x"), new Const(2)))
```
должно выдавать false.
Для тестирования программы должен быть создан класс Main, который вычисляет значение выражения x2−2x+1, для x, заданного в командной строке.
При выполнении задания следует обратить внимание на:
Выделение общего интерфейса создаваемых классов.
Выделение абстрактного базового класса для бинарных операций.

Пакет expression решает следующую задачу:
Доработайте предыдущее домашнее задание, так что бы выражение строилось по записи вида
```x * (x - 2)*x + 1```
В записи выражения могут встречаться:
бинарные операции: умножение, деление, сложение и вычитание;
унарный минус ;
переменные x, y и z;
целочисленные константы в десятичной системе счисления, помещающиеся в 32-битный знаковый целочисленный тип;
круглые скобки для явного обозначения приоритета операций;
произвольное число пробельных символов в любом месте, не влияющем на однозначность понимания формулы (например, между операцией и переменной, но не внутри констант).
Приоритет операций, начиная с наивысшего
унарный минус;
умножение и деление;
сложение и вычитание.
Разбор выражений рекомендуется производить методом рекурсивного спуска.
Алгоритм должен работать за линейное время.
Лексический анализ (токенизация) не требуется.

(Позже к прошлой реализации была добавлена обработка ошибок)
В пакете expression.generic еще одна реализация парсера, работающая в различных типах. Задача была поставлена так:
Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.
Создайте класс expression.generic.GenericTabulator, реализующий интерфейс expression.generic.Tabulator:

    public interface Tabulator {
        Object[][][] tabulate(
            String mode, String expression, 
            int x1, int x2, int y1, int y2, int z1, int z2
        ) throws Exception;
    }
            
Аргументы

mode — режим работы
Режим	Тип
i	int с детекцией переполнений
d	double
bi	BigInteger


expression — вычисляемое выражение;


x1, x2; y1, y2; z1, z2 — диапазоны изменения переменных (включительно).
Возвращаемое значение — таблица значений функции, где R[i][j][k] соответствует x = x1 + i, y = y1 + j, z = z1 + k. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть null.


(позже были добавлены типы u - int без детекции переполнений, l - long, s - short,  а также операции abs, mod и square)
